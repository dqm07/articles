<!--
 * @Author: dongqingming
 * @Date: 2021-01-22 11:28:16
 * @LastEditTime: 2021-01-29 11:57:33
 * @LastEditors: dongqingming
 * @Description: 复用与配置化
 * @FilePath: /articles/工程/复用与配置化.md
 * @no bug no code
-->
# 复用的粒度
原则可以`因地制宜`的去约定复用的粒度，组合优于继承

## 具备抽象意识
不再是面向过程的开发流程，抽象思维就是看需求共性，下沉基础能力。首先是有抽象意识，自己要意识到我要抽象，其次就是怎么抽象，这关系到复用的粒度。
看一个例子
```js
http://fangyuan.intra.xiaojukeji.com/#/rules/modifyV3/30105
// 规则/策略背景
// 规则内容
// 面相过程怎么开发
自上而下的开发，完成需求功能即可，反观代码会有很多的重复代码
// 抽象思考怎么开发
1、label + input下沉
2、大模块的抽象配置化
```

## 如何抽象
这背后其实就是抽象的粒度，一定抽的越细致约好吗，不抽象是不是也可以？

大致上是存在一些抽象原则的
### 原则
- “状态组件无模板，模板组件无状态”
```js
# 状态组件无模板 - hooks
const useAsync = (asyncFunction, immediate = true) => {
  const [status, setStatus] = useState('idle');
  const [value, setValue] = useState(null);
  const [error, setError] = useState(null);

  const execute = useCallback(() => {
    setStatus('pending');
    setValue(null);
    setError(null);

    return asyncFunction()
      .then(response => {
        setValue(response);
        setStatus('success');
      })
      .catch(error => {
        setError(error);
        setStatus('error');
      });
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return { execute, status, value, error };
};
# 模板组件无状态 - UI组件

很好理解，不做过多地解释
```
- 业务复用 > 代码复用
```js
# 举一个例子
分层的概念：业务层的复用价值更大，代码复用解决不了业务重写的问题
```
- repeat >= 2就是有意义
- 分而治之，降低维护成本
```js
# 粒度和维护之间的平衡
```
- 状态管理建议props或者hooks，组件的原则
- 不确定的项目可以尝试渐进的方式趋于完善
- 组件化 Vs 分层
- 抽象化思想 > 面向过程开发
- 原子组件：不可再拆分
- 分子组件：存在一定可操作性【label + input】
- 生物组件：环境产物【label + input + search + reset】
- 模板组件：复杂的生物组件、逻辑组件，最终归并到页面中
- 三层原则

```
组件封装原则：
  标准性：所有组件同样一套标准
  独立性：单一职责原则
  复用和易用
  短小精悍
  STOP法则：single point of truth
  避免暴露组件内逻辑
  避免直接操作dom，避免ref
  入口处检查参数有效性，出口处检查返回的正确性
  无环依赖原则
  稳定抽象原则：抽象程度决定了稳定性
  避免冗余状态：同层级复用，抽象到父节点
  合理的依赖关系
  扁平化参数
  良好的接口设计
  api尽量和已知概念保持一致

划分：
  基础组件
    antd elementUI等
  容器型组件
  展示型组件
    stateless组件
  业务组件
    常规components
  通用组件
    ui组件
      props、events和slots即可交互
    逻辑组件
      功能组件
  高阶组件

边界：
  不超过三层（容器、业务和通用）
  拆分是否再有必要？
```

### 总结
因地制宜，整体评估，但是有一些原则可依循的

react: 逻辑处理中间件思路（数据单向流进行劫持，异常处理机制拦截，react拥有双向流）ErrorBoundary
jsx模板化，通过babel-plugin进行支持即可
