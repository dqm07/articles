# 算法

## 动态规划
### 概念
是一种算法策略，相较于暴力方式找到答案，她是一种更加“聪明”的方式，而且时间复杂度上也不高。

### 三要素
- 存在最优子结构
- 存在重复子问题
- 无后效性

### 最优子结构
子问题的最优解可以推导出全局最优解，从问题中找到子问题，并且通过子问题的最优解建立与全局问题之间的关系，这个这个要素最关键也最难的地方。

举个栗子：爬楼梯问题中，爬的前几层则是走完全局的子问题，先找到前几层的最优解，那么爬完全局的最优路径可以从前几层的最优解中推导出来，因为后面的每一层都依赖前几层的结果。

### 重复子问题
同一个子问题在不同场景下存在重复计算，重复计算的问题就不需要重复执行

同样是爬楼问题，例如爬到第二层还是第三层，那么第一层就是必经之层，这部分的计算无论计算第二层地三层都只会执行一次。

### 无后效性
前面的选择不会影响后面的游戏规则

什么是有后效性呢？你的人生！那什么是没有后效性呢？背包问题、寻路等，这些的选择都不会影响背包大小和地图的地形。

### 套路-状态转移方程
简而言之，通过之前某些步骤推导出未来步骤。`对于复杂问题，难在如何定义i的含义，以及下一步状态如何通过之前状态推导`。

看例子吧

#### 爬楼问题
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？（给定 n 是一个正整数）

- 明确子结构：第n阶一定可以从n-1和n-2推导出来，存在子结构
- 明确子问题：n阶的爬法存在n-1、n-2的爬法，n-1的爬法存在n-2爬法，存在重复问题
- 明确后效性：不存在，无论现在1阶还是2阶都不影响n的值，也不会影响下一次爬行的距离

因此可以确认可以通过动态规划来处理，1、2无法运用通用状态转移方程，所以需要枚举，具体逻辑如下。

```js
function dp(i: number) {
  switch(i) {
    case 1:
      return 1;
    case 2:
      return 2;
    default:
      return dp(i-1) + dp(i-2);
  }
}

dp(n);
```
当然，我们可以进一步优化逻辑，通过缓存减少dp的计算次数，甚至优化存储的冗余数据，因为我们每次只用前两次的数据。

#### 最大子序和
> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

- dp(i) = dp(i-1) + nums[i], 如果dp(i-1) > 0
- dp(i) = nums[i], 如果dp(i-1) <= 0

#### 最长递增子序列——中等题
> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

- dp(i) = max(dp[j]) + 1, 其中0 <= j < i && num[j] < num[i]

#### 最长有效括号——困难题
> 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

- dp(i) = dp(i-1) + dp(i - dp(i-1)), 如果i项与dp(i-1)前一项没有匹配
- dp(i) = dp(i-1) + dp(i - dp(i-1) - 2) + 2, 如果i项与dp(i-1)前一项匹配了

`面对复杂问题，不要盯着全流程看，充分认可dp(i-x)已经计算出来的含义，进行高度抽象的思考。`

### 总结
- 定义清楚dp(i)是什么
- 定义状态转移方程，需要思考技巧
- 验证正确性